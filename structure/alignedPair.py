# Import required modules
import pysam
from ngs_analysis.general import iohandle

class ReadPairs(object):
    ''' This class extracts HiC read pairs from a BAM files containing
    aligned reads from a paired end HiC sequence library. The names of
    read1 reads should have a ':1' while the names of the read2 reads
    should have a ':2' suffix. All secondary alignments, within the BAM
    file should be marked.
    '''
    
    def __init__(self, bamFile):
        ''' Initialise object with a path to a BAM file '''
        # Create key variables
        self.bam = bamFile
        strDict = {True : "-", False : "+"}
        self.chrDict = {}
        # Populate chromsome dictionary
        inBam = pysam.AlignmentFile(bamFile, 'rb')
        for reference in inBam.references:
            tid = inBam.gettid(reference)
            self.chrDict[tid] = reference
        inBam.close()
    
    def concordant(self, reads, maxSize):
        ''' Function to find concordant pairs. Input is a list/tuple
        that sequentially contains the chromosome, start, end and
        strand. Start is the most 5' base on the genome to which the
        read aligns. End is the most 3' base on the genome to which
        the read aligns.
        '''
        # Initialise return variable
        returnVariable = False
        # Only examine reads on same chromsomes and different strands
        if reads[0] == reads[4] and reads[3] != reads[7]:
            if reads[3] == '+':
                # Calculate and check read distance:
                distance = reads[6] - reads[1]
                if distance < maxSize:
                    # Check that no read extends beyond its pair
                    if (reads[5] - reads[1] >= 0 and
                        reads[6] - reads[2] >= 0):
                        returnVariable = True
            elif reads[3] == '-':
                # Calculate and check read distance:
                distance = reads[2] - reads[5]
                if distance < maxSize:
                    # Check that no portion of read2 is 5' of read1
                    if (reads[2] - reads[6] >= 0 and
                        reads[1] - reads[5] >= 0):
                        returnVariable = True
        # Retrun return variable
        return(returnVariable)

    def output(self, readPairs, pairOut, rmDup, rmConcord, maxSize, alignLog):
        ''' Function to output read pairs generated from the extract
        function while processing concordant and duplicate reads.
        Function takes five arguments:
        
        1)  readPairs - a read pair dictionary created by the extract
            function.
        2)  pairOut - output object which is processed by the
            iohandle.handleout function.
        3)  rmDup - Boolean indicating whether to remove duplicates
            from the output.
        4)  rmConcord - Boolean indicating whether to remove concordant
            pairs from the output.
        5)  alignLog - log dictionary generated by the extract
            function.
        
        Function returns two items:
        
        1)  A closed iohandle.handleout object
        2)  The altered alignLog from the input
        
        '''
        # Open output and loop through input
        outData = iohandle.handleout(pairOut)
        for pair in sorted(readPairs):
            # Extract count and duplicates
            count = readPairs[pair]
            alignLog['duplicates'] += (count - 1)
            # Check for concordancy
            if self.concordant(pair, maxSize):
                alignLog['concordant'] += count
                if rmConcord:
                    continue
            # Output data with duplicates processed
            if rmDup:
                outData.add(pair)
            else:
                for _ in range(count):
                    outData.add(pair)
        # Return data from function
        return(outData.close(), alignLog)

    def extract(self, outPairs, minMapQ = 20, maxSize = 2000,
        rmConcord = True, rmDup = True):
        ''' Function to output read pairs generated from the extract
        function while processing concordant and duplicate reads.
        Function takes five arguments:
        
        1)  outPairs - an output object which is processed by the
            iohandle.handleout function.
        2)  minMapQ - minimum mapping quality for a read to be
            processed,
        3)  maxSize - maximum size of read pair for it to be considered
            concordant.
        4)  rmConcord - Boolean indicating whether to remove concordant
            pairs from the output.
        5)  rmDup - Boolean indicating whether to remove duplicates
            from the output.
        
        Function returns two items:
        
        1)  A closed iohandle.handleout object
        2)  The altered alignLog from the input
        
        '''
        # Open bamfile
        bamFile = pysam.AlignmentFile(inBam, 'rb')
        # Generate dictionaries to store ligated fragend data and alignment metrics
        pairDict = collections.defaultdict(int)
        alignCount = collections.OrderedDict([
            ('total', 0),
            ('secondary', 0),
            ('unmapped', 0),
            ('poorly mapped', 0),
            ('singletons', 0),
            ('mutltiple', 0),
            ('pairs', 0),
            ('concordant', 0),
            ('duplicates', 0)
        ])
        # Initialise variables to store read data
        currentName = ""
        readList = []
        # Loop through BAM file
        while True:
            # Extract read data
            try:
                read = bamFile.next()
                readName = read.query_name
                alignCount['total'] += 1
            except StopIteration:
                readName = 'EndOfFile'
            # Process completed families
            if readName[:-2] != currentName[:-2]:
                # Count number of reads with identical ID
                readNo = len(readList)
                # Count and process properly mapped read-pairs
                if readNo == 2:
                    # Unpack reads and check for read1 and read2
                    read1, read2 = readList
                    if (read1.query_name.endswith(':1') and 
                        read2.query_name.endswith(':2')):
                        # Count pairs and store data
                        output = (
                            self.chrDict[read1.reference_id],
                            read1.reference_start + 1,
                            read1.reference_end,
                            self.strDict[read1.is_reverse],
                            self.chrDict[read2.reference_id],
                            read2.reference_start + 1,
                            read2.reference_end,
                            self.strDict[read2.is_reverse],
                        )
                        pairDict[output] += 1
                        alignCount['pairs'] += 2
                    # If not, count as multiple alignments
                    else:
                        alignCount['multiple'] += 2
                # Count single mapped and multi mapped reads
                elif readNo == 1:
                    alignCount['singletons'] += 1
                elif readNo == 0:
                    continue
                else:
                    alignCount['multiple'] += readNo
                # Reset read list and current name
                currentName = readName
                readList = []
            # Break loop at end of BAM file
            if readName == 'EndOfFile':
                break
            # Count and skip secondary alignments
            elif (256 & read.flag):
                alignCount['secondary'] += 1
            # Count and skip umapped reads
            elif (4 & read.flag):
                alignCount['unmapped'] += 1
            # Count and skip poorly mapped reads
            elif read.mapping_quality < minMapQ:
                alignCount['poormap'] += 1
            # Process reads of sufficient quality
            else:
                readList.append(read)
        # Close BAM file and return data
        bamFile.close()
        # Output data
        functionOut = self.output(readPairs = pairDict, pairOut = outPairs,
            rmDup = rmDup,  rmConcord = rmConcord, maxSize = maxSize,
            alignLog = alignCount)
        return(functionOut)
