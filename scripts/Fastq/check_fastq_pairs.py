
import gzip
import multiprocessing
import subprocess
import os
import random
from Bio.SeqIO.QualityIO import FastqGeneralIterator

class extractNames(object):
    ''' Class functions as an iterator to extract reads from single or paired
    FASTQ files. Classes uses multiprocessing to speed up the extraction of
    the FASTQ entries and the FastqGeneralIterator from Bio.SeqIO to parse
    indivdual reads.
    '''
    
    def __init__(
        self, fastq1, fastq2, number=True, shell=True
    ):
        ''' Function to initialise object. Function takes five arguments:
        
        1)  fastq1 - Full path to FASTQ file.
        2)  fastq2 - Full path to paired FASTQ file (optional).
        3)  shell - Boolean indicating whether to use shell zcat command
            to read gzipped input.
        4)  number - Number of reads to extract.
        5)  sample - Number of reads from which to sample the desired number
            of read. Only used when 'number' also set.
        
        '''
        # Store variables
        self.fastq_list = [fastq1, fastq2]
        for fastq in self.fastq_list:
            if not os.path.isfile(fastq):
                raise IOError("File '{}' not found".format(fastq))
        self.shell = shell
        self.number = number
        # Create list to store process data
        self.process_list = []
    
    def __read_process(self, fastq, pend):
        ''' Function to generate a process to read FASTQ files. Extracted reads
        will be sent doen the supplied multiprocessing pipe. If self.shell is
        True then gzipped input files will be read using the zcat command in the
        shell. If self.entries is set then only the FASTQ entries at the desired
        indices will be sent down the pipe. FASTQ entries are generated as three
        element tuples consisting of: read name, base calls, base qualities.
        Function takes two arguments:
        
        1)  fastq - Full path to the FASTQ file to read
        2)  pend - End of multiprocessing pipe down which reads will be sent.
        '''
        # Create fastq handle
        if self.shell and fastq.endswith('.gz'):
            sp = subprocess.Popen(['zcat', fastq], stdout = subprocess.PIPE,
                bufsize = 1)
            fh = sp.stdout
        elif fastq.endswith('.gz'):
            fh = gzip.open(fastq)
        else:
            fh = open(fastq)
        # Extract all reads
        for read in FastqGeneralIterator(fh):
            name_list = read[0].split()
            if self.number:
                output = (name_list[0], name_list[1].split(':',1)[0])
            else:
                output = name_list[0]
            # Send data or break iteration
            try:
                self.__send(output, pend)
            except StopIteration:
                break
        # Close subprocess and file handle
        if self.shell and fastq.endswith('.gz'):
            sp.terminate()
        fh.close()
    
    def __send(self, read, pend):
        # Check pipe for incoming signal
        if pend.poll():
            # Extract signal and process
            recv = pend.recv()
            if recv is None:
                raise StopIteration('Termination signal received')
            else:
                raise ValueError('Unknown signal received')
        # Else add read to pipe
        else:
            pend.send(read)
    
    def start(self):
        ''' Function creates processes to read the FASTQ files listed in
        self.fastq_list using self.__read_process. Function creates two
        element tuples consisting of the process and pipe end with which
        to recevie FASTQ reads from the process. The tuples are stored in
        self.process_list.
        '''
        # Close active processes
        self.close()
        # Loop through fastq files:
        for fastq in self.fastq_list:
            # Create pipe and process
            pend_child, pend_parent = multiprocessing.Pipe(True)
            process = multiprocessing.Process(
                target = self.__read_process,
                args = (fastq, pend_child)
            )
            process.start()
            pend_child.close()
            # Store process data
            self.process_list.append((process, pend_parent))
    
    def close(self):
        ''' Function terminates the processes and closes the pipe-ends
        listed in self.process_list and generated by self.start. The list 
        self.process_list is then emptied.
        '''
        # Loop through processes and terminate
        for process, pend in self.process_list:
            # Add termination signal to pipes
            try:
                pend.send(None)
            except IOError:
                pass
            # Join process and close pipes
            process.join()
            pend.close()
        # Empty process list
        self.process_list = []
    
    def __iter__(self):
        ''' Returns self for iteration '''
        return(self)
    
    def next(self):
        ''' Returns next element in pipe or raises StopIteration '''
        # Return fastq pairs
        try:
            return((
                self.process_list[0][1].recv(),
                self.process_list[1][1].recv()
            ))
        except EOFError:
            raise StopIteration
    
    def __enter__(self):
        ''' Starts processes at start of with scope '''
        # Close active processes
        self.close()
        # Start new processes
        self.start()
        return(self)
    
    def __exit__(self, exception_type, exception_value, traceback):
        ''' Closes processes at end of with scope '''
        self.close()

if __name__ == "__main__":
    # Create argument parser
    import argparse
    parser = argparse.ArgumentParser(description='Check names in paired FASTQ')
    parser.add_argument('fastq1', help='Read1 FASTQ file')
    parser.add_argument('fastq2', help='Read2 FASTQ file')
    parser.add_argument('--python-gzip', action='store_true',
        help='Use python gzip module to read gzipped files')
    parser.add_argument('--name-only', action='store_true',
        help='Check read names and not number')
    args = parser.parse_args()
    # Create counters
    total = 0
    mismatch = 0
    # Create fastq iterator
    fastq_iterator = extractNames(
        fastq1=args.fastq1, fastq2=args.fastq2, number=not(args.name_only),
        shell=not(args.python_gzip))
    fastq_iterator.start()
    # Iterate through fastq files
    if args.name_only:
        for name1, name2 in fastq_iterator:
            total += 1
            if name1 != name2:
                mismatch += 1
            if not (total % 1000000):
                print('{} of {} mismatched'.format(mismatch, total))
    else:
        for (name1, no1), (name2, no2) in fastq_iterator:
            total += 1
            if name1 != name2 or no1 != '1' or no2 != '2':
                mismatch += 1
            if not (total % 1000000):
                print('{} of {} mismatched'.format(mismatch, total))
    fastq_iterator.close()
    print('\nScript complete')
    print('{} of {} mismatched'.format(mismatch, total))
