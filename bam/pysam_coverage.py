import pysam
import numpy as np
import pandas as pd
import multiprocessing
import collections

class coverage(object):

    def __init__(self, bam):
        self.bam = bam
        bamFile = pysam.AlignmentFile(bam)
        self.length = collections.OrderedDict(
            zip(bamFile.references, bamFile.lengths))
        self.name = {bamFile.gettid(x):x for x in bamFile.references}
    
    def extract_intervals(
            self, intervals, pipe_out, map_quality = 0, remove_dup = False
        ):
        bamFile = pysam.AlignmentFile(self.bam)
        for interval in intervals:
            pipe_out.send(interval)
            chrom, start, end = interval
            for read in bamFile.fetch(chrom, start, end):
                if read.is_unmapped:
                    continue
                if read.mapping_quality < map_quality:
                    continue
                if remove_dup and read.is_duplicate:
                    continue
                pipe_out.send((
                    max(start, read.reference_start),
                    min(end, read.reference_end)
                ))
        pipe_out.close()
        bamFile.close()
    
    def coverage_change(
            self, intervals, pipe_out, map_quality = 0, remove_dup = False
        ):
        # Start process extracting intervals
        connRecv, connSend = multiprocessing.Pipe(False)
        process = multiprocessing.Process(
            target = self.extract_intervals,
            args = (intervals, connSend, map_quality, remove_dup)
        )
        process.start()
        connSend.close()
        # Process interval data generated by process
        interval = None
        while True:
            try:
                data = connRecv.recv()
            except EOFError:
                if interval is not None:
                    pipe_out.send((interval, cov_change))
                break
            try:
                start, end = data
                cov_change[start] += 1
                cov_change[end] -= 1
            except ValueError:
                if interval is not None:
                    pipe_out.send((interval, cov_change))
                interval = data
                cov_change = collections.defaultdict(int)
        # Clean up processes and pipes
        connRecv.close()
        process.join()
        pipe_out.close()
    
    def coverage_array(
            self, intervals, pipe_out, map_quality = 0, remove_dup = False,
        ):
        # Start process extracting coverage change
        connRecv, connSend = multiprocessing.Pipe(False)
        process = multiprocessing.Process(
            target = self.coverage_change,
            args = (intervals, connSend, map_quality, remove_dup)
        )
        process.start()
        connSend.close()
        # Extract data from pipe
        while True:
            try:
                interval, cov_change = connRecv.recv()
            except EOFError:
                break
            # Remove zero change items from coverage
            cov_change = {k:v for k,v in cov_change.items() if v}
            # At interval start and end to coverage
            start, end = interval[1:]
            cov_change[start] = cov_change.get(start, 0)
            cov_change[end] = cov_change.get(end, end)
            # Convert to numpy array, sort, and remove zeros
            cov_array = np.array(cov_change.items(), dtype=np.int32)
            cov_array = cov_array[cov_array[:,0].argsort()] #Is this needed
            pipe_out.send((interval, cov_array))
        # Clean up pipes and processes
        connRecv.close()
        process.join()
        pipe_out.close()
    
    def coverage_array_generator(
            self, intervals, map_quality = 0, remove_dup = False
        ):
        # Start process building coverage
        connRecv, connSend = multiprocessing.Pipe(False)
        process = multiprocessing.Process(
            target = self.coverage_array,
            args = (intervals, connSend, map_quality, remove_dup)
        )
        process.start()
        connSend.close()
        # Process coverage generated by process
        while True:
            try:
                cov_array_data = connRecv.recv()
            except EOFError:
                break
            yield(cov_array_data)
        # Clean up pipes and processes
        connRecv.close()
        process.join()
    
    def bedgraph_file(
            self, bedgraph, intervals, map_quality = 0,
            remove_dup = False
        ):
        # Open output file
        outFile = open(bedgraph, 'w')
        # Create generator and loop through arrays
        for interval, array in self.coverage_array_generator(
                intervals, map_quality, remove_dup
            ):
            # Calculate coverage
            chrom = interval[0]
            coverage = np.cumsum(array[:,1])
            if coverage[-1] != 0:
                raise ValueError('Error in coverage calculations')
            for i in range(array.shape[0] - 1):
                outLine = '{}\t{}\t{}\t{}\n'.format(
                    chrom,
                    array[i, 0],
                    array[i + 1, 0],
                    coverage[i]
                )
                outFile.write(outLine)
        outFile.close()
    
    def histogram(
            self, intervals, max_cov = 200, map_quality = 0, remove_dup = False
        ):
        # Create ordered dictionary of results
        histogram = collections.OrderedDict()
        for x in range(max_cov + 1):
            histogram[x] = 0
        # Create generator and loop through arrays
        for interval, array in self.coverage_array_generator(
                intervals, map_quality, remove_dup
            ):
            # Calculate lengths and coverage and add to histogram
            lengths = np.diff(array[:,0])
            coverage = np.cumsum(array[:,1])
            if coverage[-1] != 0:
                raise ValueError('Error in coverage calculations')
            for c, l in zip(coverage[:-1], lengths):
                histogram[min(c, max_cov)] += l
        # Return data
        return(histogram)
    
    def mean_coverage(
            self, intervals, map_quality = 0, remove_dup = False
        ):
        # Create output list
        meanList = []
        # Create generator and loop through arrays
        for interval, array in self.coverage_array_generator(
                intervals, map_quality, remove_dup
            ):
            # Calculate lengths and coverage
            lengths = np.diff(array[:,0])
            coverage = np.cumsum(array[:,1])
            if coverage[-1] != 0:
                raise ValueError('Error in coverage calculations')
            # Calculate mean coverage
            meanCov = np.average(coverage[:-1], weights=lengths)
            meanList.append(meanCov)
        # Clean up processes and pipes
        return(meanList)


#x = coverage('/farm/scratch/rs-bio-lif/rabino01/Elza/bamFiles/310123-NORM_dedup_realign_recal.bam')
#y = x.mean_coverage(intervals = [('1', 10000000, 10000100), ('2', 30000000, 30000100)])
#print(y)
